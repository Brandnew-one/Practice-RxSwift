# Traits

> Traits help communicate and ensure observable sequence properties across interface boundaries, as well as provide contextual meaning, syntactical sugar and target more specific use-cases when compared to a raw Observable, which could be used in any context.
> 

> **For that reason, Traits are entirely optional. You are free to use raw Observable sequences everywhere in your program as all core RxSwift/RxCocoa APIs support them.**
> 

ê³µì‹í™ˆí˜ì´ì§€ì— ë”°ë¥´ë©´ Traitsë¥¼ ì‚¬ìš©í•˜ë©´ ê¸°ì¡´ì˜ Observableì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ëŠ”ê²ƒ ë³´ë‹¤ ë¬¸ë§¥ì ì¸ ì˜ë¯¸, ë¬¸ë²•ì ìœ¼ë¡œ í¸í•¨, ê·¸ë¦¬ê³  íŠ¹ì •í•œ use-caseì—ì„œ ë” ë„ì›€ì´ ëœë‹¤ê³  í•œë‹¤.

ì¦‰, Traitsì—ì„œ í•  ìˆ˜ ìˆëŠ”ê±´ Observableì—ì„œë„ í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì‚¬ìš©ì€ optional í•˜ë‹¤. í•˜ì§€ë§Œ Traitsì„ ì´ë¯¸ ë§ì´ ì‚¬ìš©í•˜ê³  ìˆê³  íŠ¹ì • ìƒí™©ì—ì„œëŠ” íŠ¹ì • traitsì„ ì‚¬ìš©í•˜ëŠ”ê²Œ ì¢€ ë” ëª…í™•í•˜ê¸° ë•Œë¬¸ì— ê³µë¶€í•´ë³´ê³ ì í•œë‹¤.

---

## Single

> A Single is a variation of Observable that, instead of emitting a series of elements, is always guaranteed to emit eitherÂ *a single element* orÂ *an error*.
> 

Singleì€ ìš°ë¦¬ê°€ Observableë¥¼ ë§Œë“¤ ë•Œ ì‚¬ìš©í–ˆë˜ í•˜ë‚˜ì˜ ì´ë²¤íŠ¸ë¥¼ nextë¡œ ë°©ì¶œí•˜ê³  completed ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•´ ì‹œí€€ìŠ¤ê°€ ì¢…ë£Œë˜ë˜ justì™€ êµ‰ì¥íˆ ìœ ì‚¬í•˜ë‹¤.

ì°¨ì´ì ì€ Observableì€ next, completed, error 3ê°€ì§€ ì´ë²¤íŠ¸ê°€ ì¡´ì¬í–ˆì§€ë§Œ Singleì€ success, error 2ê°€ì§€ ì´ë²¤íŠ¸ë§Œ ì¡´ì¬í•œë‹¤.

```swift
public static func create(subscribe: @escaping (@escaping SingleObserver) -> Disposable) -> Single<Element> {
        let source = Observable<Element>.create { observer in
            return subscribe { event in
                switch event {
                case .success(let element):
                    observer.on(.next(element))
                    observer.on(.completed)
                case .failure(let error):
                    observer.on(.error(error))
                }
            }
        }
        
        return PrimitiveSequence(raw: source)
    }
```

ì‹¤ì œ êµ¬í˜„ì½”ë“œë¥¼ í†µí•´ì„œ í™•ì¸í•´ë³´ë©´ Observableì„ í†µí•´ì„œ Singleì„ êµ¬í˜„í•˜ê³  success = next + completed í˜•íƒœë¡œ êµ¬í˜„ë˜ì–´ ìˆëŠ”ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

ê·¸ë¦¬ê³  ìš°ë¦¬ëŠ” Singleì€ êµ¬ë…ë˜ë©´ success ë‚˜ error ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ê³  ì‹œí€€ìŠ¤ê°€ ì¢…ë£Œë˜ëŠ”ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.

`completed ë˜ëŠ” error ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ë©´ì„œ ì‹œí€€ìŠ¤ê°€ ì¢…ë£Œë˜ê¸° ë•Œë¬¸!`

### Singleì„ ìƒì„±í•˜ëŠ” Operator

```swift
// 1) justë¥¼ í†µí•´ ìƒì„±
Single<String>.just("ğŸ’€") // Observableê³¼ ë‹¬ë¦¬ onNext, onComplete (X)
  .subscribe(
    onSuccess: {
      print($0)
    },
    onFailure: {
      print("Error: \($0)")
    },
    onDisposed: {
      print("disposed")
    }
  )
  .disposed(by: disposeBag)

// ğŸ’€
// disposed

// 2) createë¥¼ í†µí•´ ìƒì„± -> asSingle()ì„ í†µí•´ì„œ
Observable<String>
  .create { observer -> Disposable in
    observer.onError(TraitsError.single)
    return Disposables.create()
  }
  .asSingle()
  .subscribe(
    onSuccess: {
      print($0)
    },
    onFailure: {
      print("error: \($0)")
    },
    onDisposed: {
      print("disposed")
    }
  )
  .disposed(by: disposeBag)

// error: single
// disposed
```

### ê·¸ë˜ì„œ ì–¸ì œ ì‚¬ìš©í• ê¹Œ?

ì¼ë°˜ì ìœ¼ë¡œ ì‘ë‹µ/ì˜¤ë¥˜ë§Œì„ ë°˜í™˜í•˜ëŠ” ë„¤íŠ¸ì›Œí¬ í†µì‹ ì—ì„œ ìì£¼ ì‚¬ìš©í•œë‹¤. ì‹¤ì œ ê³µì‹ í™ˆí˜ì´ì§€ ì˜ˆì œë„ ë„¤íŠ¸ì›Œí¬ í†µì‹ ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

---

## Completable

> A Completable is a variation of Observable that can onlyÂ *complete*Â orÂ *emit an error*. It is guaranteed to not emit any elements.
> 

Completableì€ completed, error ì´ë²¤íŠ¸ë§Œ ë°©ì¶œí•œë‹¤. Observableì—ì„œ next ì´ë²¤íŠ¸ê°€ ì—†ëŠ” ì •ë„ë¡œ ìƒê°í•˜ë©´ ë ê²ƒ ê°™ë‹¤.

```swift
public static func create(subscribe: @escaping (@escaping CompletableObserver) -> Disposable) -> PrimitiveSequence<Trait, Element> {
        let source = Observable<Element>.create { observer in
            return subscribe { event in
                switch event {
                case .error(let error):
                    observer.on(.error(error))
                case .completed:
                    observer.on(.completed)
                }
            }
        }
        
        return PrimitiveSequence(raw: source)
    }
```

ì‹¤ì œ êµ¬í˜„ì½”ë“œì˜ createì—ì„œë„ next ì´ë²¤íŠ¸ëŠ” ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

### Completableì„ ë§Œë“œëŠ” Operator

```swift
Completable.create { observer -> Disposable in
  observer(.error(TraitsError.completable))
  return Disposables.create()
}
.subscribe(
  onCompleted: {
    print("Completed")
  },
  onError: {
    print("error: \($0)")
  },
  onDisposed: {
    print("disposed")
  }
)
.disposed(by: disposeBag)

// error: completable
// disposed
```

ë‹¤ë¥¸ traitsë“¤ê³¼ ë‹¬ë¦¬ Completableì€ Observableì„ Completableë¡œ ë§Œë“¤ ìˆ˜ ì—†ë‹¤.

### ê·¸ë˜ì„œ ì–¸ì œ ì‚¬ìš©í• ê¹Œ?

ê²°ê³¼ê°’ì´ ì—†ê±°ë‚˜ í•„ìš”í•˜ì§€ì•Šì€ ê²½ìš°ì˜ ì„±ê³µ ì—¬ë¶€ë¥¼ í™•ì¸í•  ë•Œ ì‚¬ìš©í•œë‹¤ê³  í•œë‹¤. ê³µì‹ í™ˆí˜ì´ì§€ì—ì„œëŠ” ë¡œì»¬ì— ìºì‹œë¥¼ ì €ì¥í•˜ëŠ” ê²½ìš°ë¥¼ ì˜ˆë¡œ ë“¤ê³  ìˆë‹¤.

---

## Maybe

> A Maybe is a variation of Observable that is right in between a Single and a Completable. It can either emit a single element, complete without emitting an element, or emit an error.
> 

MaybeëŠ” Single + Completable ì´ë‹¤. MaybeëŠ” success, error, completed 3ê°œì˜ ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•  ìˆ˜ ìˆë‹¤.

```swift
public static func create(subscribe: @escaping (@escaping MaybeObserver) -> Disposable) -> PrimitiveSequence<Trait, Element> {
        let source = Observable<Element>.create { observer in
            return subscribe { event in
                switch event {
                case .success(let element):
                    observer.on(.next(element))
                    observer.on(.completed)
                case .error(let error):
                    observer.on(.error(error))
                case .completed:
                    observer.on(.completed)
                }
            }
        }
        
        return PrimitiveSequence(raw: source)
    }
```

Singleê³¼ ë§ˆì°¬ê°€ì§€ë¡œ success ì´ë²¤íŠ¸ëŠ” ê°’ì„ ê°€ì§„ ì´ë²¤íŠ¸ë¥¼ next ì´ë²¤íŠ¸ë¡œ ë°©ì¶œí•˜ê³  completed ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ë©´ì„œ ì¢…ë£Œëœë‹¤. í•˜ì§€ë§Œ completedë¥¼ í†µí•´ ê°’ë„ ë°©ì¶œí•˜ì§€ ì•Šê³  complete ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ë©´ì„œ ì‹œí€€ìŠ¤ë¥¼ ì¢…ë£Œí•  ìˆ˜ ìˆë‹¤.

- ì–´ë–¤ê°’ì„ ê°€ì§„ ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ê³  ì¢…ë£Œ
- ì—ëŸ¬ ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ê³  ì¢…ë£Œ
- ì•„ë¬´ëŸ° ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ì§€ ì•Šê³  ì¢…ë£Œ

ì •ë¦¬í•˜ìë©´ MaybeëŠ” êµ¬ë…ë˜ëŠ” ì‹œì ì— ìœ„ì˜ 3ê°€ì§€ ìƒëª…ì£¼ê¸° ì¤‘ í•˜ë‚˜ë¥¼ ê°€ì§„ë‹¤.

### Maybeë¥¼ ë§Œë“œëŠ” Operator

```swift
// 1) just
Maybe<String>.just("ğŸ’©")
  .subscribe(
    onSuccess: {
      print($0)
    },
    onError: {
      print($0)
    },
    onCompleted: {
      print("completed")
    },
    onDisposed: {
      print("disposed")
    }
  )
  .disposed(by: disposeBag)

// ğŸ’©
// disposed

// 2) create
Observable<String>.create { observer in
  observer.onNext("1")
  observer.onCompleted()
  return Disposables.create()
}
.asMaybe()
.subscribe(
  onSuccess: {
    print($0)
  },
  onError: {
    print($0)
  },
  onCompleted: {
    print("completed")
  },
  onDisposed: {
    print("disposed")
  }
)
.disposed(by: disposeBag)

// 1
// disposed

// 3) 2ê°œì˜ next ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ë©´ Maybeë¡œ ë³€í™˜í•  ìˆ˜ ìˆì„ê¹Œ?
Observable<String>.create { observer in
  observer.onNext("1")
  observer.onNext("2")
  observer.onCompleted()
  return Disposables.create()
}
.asMaybe()
.subscribe(
  onSuccess: {
    print($0)
  },
  onError: {
    print($0)
  },
  onCompleted: {
    print("completed")
  },
  onDisposed: {
    print("disposed")
  }
)
.disposed(by: disposeBag)

// Sequence contains more than one element.
// disposed
```

Maybe ì—­ì‹œ í•˜ë‚˜ì˜ ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•œë‹¤ëŠ” ê´€ì ì—ì„œ justë¥¼ í†µí•´ì„œ ìƒì„±í•  ìˆ˜ ìˆë‹¤.

Observableë¥¼ .asMaybe() í†µí•´ì„œ Maybeë¡œ ë³€í™˜í•  ìˆ˜ ìˆëŠ”ë° ì´ë•Œ ë§Œì•½ Observableì´ Maybeì˜ ì¡°ê±´ (ìœ„ì˜ 3ê°œ)ì—ì„œ ë²—ì–´ë‚˜ë©´ ìœ„ì™€ ê°™ì´ errorë¥¼ ë°©ì¶œí•˜ëŠ” ê²ƒì„ í™•ì¸ í•  ìˆ˜ ìˆë‹¤.

---

RxCocoa ì—ì„œ ì‚¬ìš©í•˜ëŠ” traitsì¸ Driverë„ ìˆëŠ”ë° ì´ëŠ” RxCocoaë¥¼ ì •ë¦¬í•˜ë©´ì„œ ì¶”ê°€ì ìœ¼ë¡œ ì •ë¦¬í•  ì˜ˆì •ì´ë‹¤.